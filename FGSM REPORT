MAIN
The Fast Gradient Sign Method is an algorithm that is typically used to make small changes to an input image to create a new image that would fool a classifier. This method was conducted by computing the gradient of a loss function in accordance with the input image and then adding a perturbation to the image in the direction of the sign gradient, which is scaled by the value of epsilon. To create this algorithm, first, a test image was loaded in and modified into a matrix. Then the dandelion model is loaded into the R session and the functions for loss and gradient were created to be used in the main FGSM function. The loss function was coded to compute the loss of the model between the input image and the target label you want the classifier to classify it as. The loss is calculated as the negative log of the probability of the target label. The gradient function was coded to calculate the gradient of the loss function with respect to the image. The main FGSM function was coded as the main function that creates the altered image. The functions inputs are the input image, the model, the target label, the epsilon value, and the pixel ratio. The function computes the gradient, randomly selects 1 percent of pixels, and then adds the perturbation to the pixels creating an altered image. The output of the function should be an altered image matrix that should fool the classifier. This was the intent of using the FGSM method. Although the algorithm runs fine, and in theory should fool the classifier, it was unable to do so. The potential reasons are listed in the Testing section of the Appendix. Overall this algorithm should be a successful way to fool an image classifier, by using machine learning to calculate the most effective perturbation to add to the image using the model and test image.

TESTING

 The FGSM attack algorithm was performed on multiple images that were then used to then try and fool the classifier. While the algorithm was successful in running, it was unable to fool the classifier. Testing was conducted by altering the image and then seeing the percentage that the image classifier returned. This percentage was then compared to the original image percentage. After multiple tests it was concluded that the difference in percentage was 0 percent, meaning that the algorithm failed to make any change in classification. There could be several reasons for this. Firstly, the algorithm is intended to change each pixel by a small percentage, so the constraint of only altering one percent of pixels gets in the way. Potentially if the algorithm could change all of the pixels by changing each pixel by one percent, it would have been closer in fooling the classifier. Another reason is that there is an error in the algorithm itself we have been unable to diagnose. With more testing, the potential undetected errors would have been able to be uncovered. The altered image looks very similar to the input image, which lines up with the correctness of the algorithm because it is meant to make small unnoticeable changes.
 
 RUNTIME
 Overall, the runtime of the FGSM algorithm varied, but the average runtime was about five minutes. This is much longer than we would have liked and attempts were made to lower the runtime, but there was no solution found that would lower the time without jeopardizing algorithm integrity. The worst walltime recorded was about seven minutes. The overally complexity of this algorithm contributes to the long times recorded, as the algorithm is altering a large number of pixels and calculating the loss and gradient of the entire image with respect to the model.
 
 PERFORMANCE
 While the FGSM algorithm we implemented was able to alter an image, it was unable to fool the classifier. Using the algorithm, a perturbation was added to one percent of the pixels of the image. In terms of task, the algorithm was successful in altering the image but unsuccessful in fooling the image classifier. The function took around five minutes to run, which makes sense due to the amount of computer calculations going on. These calculations include loss, gradient, randomly selecting pixels, and adding the changed pixels back into the image.
 
 JUSTIFICATION
 The Fast Gradient Sign Method was chosen due to its ability to go undetected by the naked eye. This method is also effective due to its use of the gradient of loss between the model and the image to be altered. It is versatile due to the fact that the values entered into the function could be adjusted in order to reach the desired outcome. Although all of these factors are beneficial for fooling a classifier, our algorithm was unable to do so due to potential algorithm incorrectness and project and time constraints.
